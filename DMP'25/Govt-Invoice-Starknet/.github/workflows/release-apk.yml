name: Automated APK Release

on:
  pull_request:
    types: [closed, labeled]
    branches: [main]

permissions:
  contents: write # For pushing commits and tags
  pull-requests: read # For reading PR information

jobs:
  check-release-trigger:
    if: github.event.pull_request.merged == true || (github.event.action == 'labeled' && github.event.pull_request.merged == true)
    runs-on: ubuntu-latest
    outputs:
      should-release: ${{ steps.check.outputs.should-release }}
      version-bump: ${{ steps.check.outputs.version-bump }}
      release-notes: ${{ steps.check.outputs.release-notes }}
    steps:
      - name: Check Release Trigger
        id: check
        run: |
          # Check if PR has release label or [release] in title
          LABELS="${{ join(github.event.pull_request.labels.*.name, ' ') }}"
          TITLE="${{ github.event.pull_request.title }}"
          PR_BODY="${{ github.event.pull_request.body }}"
          ACTION="${{ github.event.action }}"

          echo "Action: $ACTION"
          echo "Checking labels: $LABELS"
          echo "Checking title: $TITLE"
          echo "PR merged: ${{ github.event.pull_request.merged }}"          # Determine version bump type from commit messages and PR title
          VERSION_BUMP="patch"
          if [[ "$TITLE" == *"[major]"* ]] || [[ "$TITLE" == *"BREAKING CHANGE"* ]]; then
            VERSION_BUMP="major"
          elif [[ "$TITLE" == *"[minor]"* ]] || [[ "$TITLE" == *"feat"* ]] || [[ "$TITLE" == *"feature"* ]]; then
            VERSION_BUMP="minor"
          fi

          # Check if should release
          SHOULD_RELEASE=false
          if [[ "$LABELS" == *"release"* ]] || [[ "$TITLE" == *"[release]"* ]]; then
            SHOULD_RELEASE=true
          fi

          # Special handling for label events - check if release label was just added
          if [[ "$ACTION" == "labeled" ]]; then
            ADDED_LABEL="${{ github.event.label.name }}"
            echo "Label added: $ADDED_LABEL"
            if [[ "$ADDED_LABEL" != "release" ]]; then
              echo "Label '$ADDED_LABEL' is not a release trigger, skipping..."
              SHOULD_RELEASE=false
            fi
          fi

          # Prepare release notes from PR body
          RELEASE_NOTES=$(echo "$PR_BODY" | head -n 20)

          echo "should-release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "version-bump=$VERSION_BUMP" >> $GITHUB_OUTPUT
          echo "release-notes<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  build-and-release:
    needs: check-release-trigger
    if: needs.check-release-trigger.outputs.should-release == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Extract Repository Name
        id: repo-name
        run: |
          REPO_NAME="${{ github.repository }}"
          REPO_NAME_ONLY="${REPO_NAME##*/}"
          echo "full=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "name=$REPO_NAME_ONLY" >> $GITHUB_OUTPUT
          echo "Repository: $REPO_NAME"
          echo "App name: $REPO_NAME_ONLY"

      - name: Check for Existing Release
        id: check-existing
        run: |
          # Get current version first
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          BUMP_TYPE="${{ needs.check-release-trigger.outputs.version-bump }}"

          # Parse current version
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}

          # Calculate new version
          case $BUMP_TYPE in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"

          # Check if tag already exists
          if git rev-parse "v$NEW_VERSION" >/dev/null 2>&1; then
            echo "âš ï¸ Tag v$NEW_VERSION already exists!"
            echo "existing=true" >> $GITHUB_OUTPUT
            
            # Check if GitHub release exists
            RELEASE_EXISTS=$(gh release view "v$NEW_VERSION" >/dev/null 2>&1 && echo "true" || echo "false")
            echo "github-release-exists=$RELEASE_EXISTS" >> $GITHUB_OUTPUT
            echo "skip-build=true" >> $GITHUB_OUTPUT
          else
            echo "âœ… No existing release found for v$NEW_VERSION"
            echo "existing=false" >> $GITHUB_OUTPUT
            echo "github-release-exists=false" >> $GITHUB_OUTPUT
            echo "skip-build=false" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect Package Manager
        id: package-manager
        run: |
          # Detect package manager based on lock files
          if [ -f "pnpm-lock.yaml" ]; then
            echo "manager=pnpm" >> $GITHUB_OUTPUT
            echo "lockfile=pnpm-lock.yaml" >> $GITHUB_OUTPUT
            echo "cache-path=~/.pnpm-store" >> $GITHUB_OUTPUT
            echo "install-cmd=pnpm install --frozen-lockfile" >> $GITHUB_OUTPUT
            echo "run-cmd=pnpm run" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Detected package manager: pnpm"
          elif [ -f "yarn.lock" ]; then
            echo "manager=yarn" >> $GITHUB_OUTPUT
            echo "lockfile=yarn.lock" >> $GITHUB_OUTPUT
            echo "cache-path=~/.yarn/cache" >> $GITHUB_OUTPUT
            echo "install-cmd=yarn install --frozen-lockfile" >> $GITHUB_OUTPUT
            echo "run-cmd=yarn" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Detected package manager: yarn"
          elif [ -f "package-lock.json" ]; then
            echo "manager=npm" >> $GITHUB_OUTPUT
            echo "lockfile=package-lock.json" >> $GITHUB_OUTPUT
            echo "cache-path=~/.npm" >> $GITHUB_OUTPUT
            echo "install-cmd=npm ci" >> $GITHUB_OUTPUT
            echo "run-cmd=npm run" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Detected package manager: npm"
          else
            echo "manager=npm" >> $GITHUB_OUTPUT
            echo "lockfile=none" >> $GITHUB_OUTPUT
            echo "cache-path=~/.npm" >> $GITHUB_OUTPUT
            echo "install-cmd=npm install" >> $GITHUB_OUTPUT
            echo "run-cmd=npm run" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ No lock file found, defaulting to npm"
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: ${{ steps.package-manager.outputs.manager }}

      - name: Setup PNPM (if detected)
        if: steps.package-manager.outputs.manager == 'pnpm'
        uses: pnpm/action-setup@v2
        with:
          version: latest

      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            ${{ steps.package-manager.outputs.cache-path }}
          key: ${{ runner.os }}-${{ steps.package-manager.outputs.manager }}-${{ hashFiles(format('**/{0}', steps.package-manager.outputs.lockfile)) }}
          restore-keys: |
            ${{ runner.os }}-${{ steps.package-manager.outputs.manager }}-

      - name: Setup Java JDK
        uses: actions/setup-java@v4
        with:
          distribution: "zulu"
          java-version: "21"

      - name: Install Dependencies
        run: |
          echo "Installing dependencies with ${{ steps.package-manager.outputs.manager }}..."
          ${{ steps.package-manager.outputs.install-cmd }}
          echo "âœ… Dependencies installed successfully"

      - name: Setup Environment Variables
        run: |
          echo "ðŸ”§ Setting up environment variables..."

          # Create .env file if your app requires one
          # UNCOMMENT AND MODIFY THE LINES BELOW TO ADD YOUR ENVIRONMENT VARIABLES
          # Replace the placeholder values with your actual environment variables

          # cat > .env << EOF
          # # API Configuration
          # API_BASE_URL=${{ secrets.API_BASE_URL }}
          # API_KEY=${{ secrets.API_KEY }}
          # 
          # # Database Configuration  
          # DATABASE_URL=${{ secrets.DATABASE_URL }}
          # 
          # # Authentication
          # JWT_SECRET=${{ secrets.JWT_SECRET }}
          # OAUTH_CLIENT_ID=${{ secrets.OAUTH_CLIENT_ID }}
          # OAUTH_CLIENT_SECRET=${{ secrets.OAUTH_CLIENT_SECRET }}
          # 
          # # Third-party Services
          # FIREBASE_CONFIG=${{ secrets.FIREBASE_CONFIG }}
          # ANALYTICS_ID=${{ secrets.ANALYTICS_ID }}
          # 
          # # App Configuration
          # APP_ENV=production
          # DEBUG=false
          # LOG_LEVEL=info
          # EOF

          # For apps with multiple .env files (e.g., .env.production, .env.staging):
          # cat > .env.production << EOF
          # NODE_ENV=production
          # API_URL=${{ secrets.PROD_API_URL }}
          # DATABASE_URL=${{ secrets.PROD_DATABASE_URL }}
          # EOF

          # For React Native or Expo apps, you might need:
          # cat > .env << EOF
          # EXPO_PUBLIC_API_URL=${{ secrets.EXPO_PUBLIC_API_URL }}
          # EXPO_PUBLIC_APP_ENV=production
          # EOF

          echo "ðŸ“ Instructions for setup:"
          echo "1. Add your secrets to GitHub repository settings: Settings > Secrets and variables > Actions"
          echo "2. Uncomment and modify the .env creation block above with your actual environment variables"
          echo "3. Make sure your app's .gitignore includes .env files to keep secrets secure"
          echo "âœ… Environment setup completed (modify this step as needed for your app)"

      - name: Get Current Version
        id: current-version
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Calculate New Version
        id: new-version
        run: |
          CURRENT="${{ steps.current-version.outputs.current }}"
          BUMP_TYPE="${{ needs.check-release-trigger.outputs.version-bump }}"

          # Parse current version
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}

          # Calculate new version based on bump type
          case $BUMP_TYPE in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "new=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Update Version in Files
        if: steps.check-existing.outputs.skip-build == 'false'
        run: |
          NEW_VERSION="${{ steps.new-version.outputs.new }}"

          # Update package.json version based on package manager
          case "${{ steps.package-manager.outputs.manager }}" in
            "pnpm")
              pnpm version $NEW_VERSION --no-git-tag-version
              ;;
            "yarn")
              yarn version --new-version $NEW_VERSION --no-git-tag-version
              ;;
            *)
              npm version $NEW_VERSION --no-git-tag-version
              ;;
          esac

          # Update Android versionName and versionCode
          VERSION_CODE=$(grep "versionCode" android/app/build.gradle | grep -o '[0-9]\+')
          NEW_VERSION_CODE=$((VERSION_CODE + 1))

          sed -i "s/versionCode $VERSION_CODE/versionCode $NEW_VERSION_CODE/" android/app/build.gradle
          sed -i "s/versionName \".*\"/versionName \"$NEW_VERSION\"/" android/app/build.gradle

          echo "Updated version to $NEW_VERSION (code: $NEW_VERSION_CODE)"

      - name: Release Already Exists
        if: steps.check-existing.outputs.skip-build == 'true'
        run: |
          echo "## âš ï¸ Release Already Exists"
          echo "A release for this version already exists. Skipping build to prevent duplicates."
          echo "If you need to rebuild, please:"
          echo "1. Delete the existing tag and release, OR"
          echo "2. Increment the version manually and re-trigger"

      - name: Setup Keystore
        if: steps.check-existing.outputs.skip-build == 'false'
        run: |
          # Decode base64 keystore and create the actual keystore file
          echo "${{ secrets.RELEASE_KEYSTORE_BASE64 }}" | base64 -d > android/app/temp-keystore.jks

          # Create keystore.properties with paths to the actual keystore file
          cat > android/keystore.properties << EOF
          # Android Release Signing Configuration
          RELEASE_STORE_FILE=./temp-keystore.jks
          RELEASE_STORE_PASSWORD=${{ secrets.RELEASE_STORE_PASSWORD }}
          RELEASE_KEY_ALIAS=${{ secrets.RELEASE_KEY_ALIAS }}
          RELEASE_KEY_PASSWORD=${{ secrets.RELEASE_KEY_PASSWORD }}
          EOF

          echo "âœ… Keystore file created and configuration set up"

      - name: Build Release APK
        if: steps.check-existing.outputs.skip-build == 'false'
        run: |
          # Build web assets first
          echo "ðŸ—ï¸ Building web assets..."
          ${{ steps.package-manager.outputs.run-cmd }} build

          # Sync with Capacitor
          echo "ðŸ”„ Syncing with Capacitor..."
          npx cap sync android

          # Build Android APK
          echo "ðŸ”¨ Building Android APK..."
          cd android
          chmod +x gradlew
          ./gradlew assembleRelease --stacktrace

          # Verify APK was created
          if [ ! -f "app/build/outputs/apk/release/app-release.apk" ]; then
            echo "âŒ APK build failed!"
            exit 1
          fi

          # Rename APK with version and repo name
          NEW_VERSION="${{ steps.new-version.outputs.new }}"
          REPO_NAME="${{ steps.repo-name.outputs.name }}"
          cp app/build/outputs/apk/release/app-release.apk app/build/outputs/apk/release/${REPO_NAME}-v${NEW_VERSION}.apk

          # Get APK info
          APK_SIZE=$(du -h app/build/outputs/apk/release/${REPO_NAME}-v${NEW_VERSION}.apk | cut -f1)
          echo "âœ… APK built successfully! Size: $APK_SIZE"

      - name: Create Git Tag
        if: steps.check-existing.outputs.skip-build == 'false'
        run: |
          NEW_VERSION="${{ steps.new-version.outputs.new }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add package.json android/app/build.gradle
          git commit -m "ðŸ”– Release version v$NEW_VERSION"
          git tag -a "v$NEW_VERSION" -m "Release version v$NEW_VERSION"
          git push origin main
          git push origin "v$NEW_VERSION"

      - name: Generate Release Notes
        if: steps.check-existing.outputs.skip-build == 'false'
        id: release-notes
        run: |
          NEW_VERSION="${{ steps.new-version.outputs.new }}"
          CURRENT_VERSION="${{ steps.current-version.outputs.current }}"

          # Create comprehensive release notes
          cat > release-notes.md << EOF
          ## ðŸš€ What's New in v$NEW_VERSION

          ### ðŸ“‹ Changes from PR #${{ github.event.pull_request.number }}
          **${{ github.event.pull_request.title }}**

          ${{ needs.check-release-trigger.outputs.release-notes }}

          ### ðŸ“Š Release Information
          - **Previous Version:** v$CURRENT_VERSION
          - **New Version:** v$NEW_VERSION  
          - **Version Bump:** ${{ needs.check-release-trigger.outputs.version-bump }}
          - **Build Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          - **Commit SHA:** ${{ github.sha }}

          ### ðŸ’» Installation
          1. Download the APK file below
          2. Enable "Install from Unknown Sources" in Android settings
          3. Install the APK on your device

          ### ðŸ”§ Technical Details
          - **Min SDK:** 21 (Android 5.0)
          - **Target SDK:** 34 (Android 14)
          - **Architecture:** Universal APK
          - **Signed:** Yes âœ…

          ---
          *This release was automatically generated by GitHub Actions*
          EOF

          echo "Release notes generated successfully"

      - name: Create GitHub Release
        if: steps.check-existing.outputs.skip-build == 'false'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.new-version.outputs.new }}
          name: ${{ steps.repo-name.outputs.name }} v${{ steps.new-version.outputs.new }}
          body_path: release-notes.md
          files: |
            android/app/build/outputs/apk/release/${{ steps.repo-name.outputs.name }}-v${{ steps.new-version.outputs.new }}.apk
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup
        if: always()
        run: |
          # Remove sensitive files
          rm -f android/keystore.properties
          rm -f android/temp-keystore.jks

          # Remove environment files that may contain secrets
          rm -f .env
          rm -f .env.production
          rm -f .env.staging
          rm -f .env.local
          rm -f .env.development

          echo "ðŸ§¹ Cleanup completed - removed keystore and environment files"

      - name: Post-Release Summary
        if: steps.check-existing.outputs.skip-build == 'false'
        run: |
          NEW_VERSION="${{ steps.new-version.outputs.new }}"
          REPO_NAME="${{ steps.repo-name.outputs.name }}"
          APK_PATH="android/app/build/outputs/apk/release/${REPO_NAME}-v${NEW_VERSION}.apk"
          APK_SIZE=$(du -h "$APK_PATH" | cut -f1)

          echo "## ðŸŽ‰ Release Summary"
          echo "âœ… **Repository:** $REPO_NAME"
          echo "âœ… **Version:** v$NEW_VERSION"
          echo "âœ… **Package Manager:** ${{ steps.package-manager.outputs.manager }}"
          echo "âœ… **APK Size:** $APK_SIZE"
          echo "âœ… **Release URL:** ${{ github.server_url }}/${{ github.repository }}/releases/tag/v$NEW_VERSION"
          echo "âœ… **Status:** Successfully Released!"

  notify-failure:
    needs: [check-release-trigger, build-and-release]
    if: failure() && needs.check-release-trigger.outputs.should-release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Notify Build Failure
        run: |
          echo "âŒ Release build failed for PR #${{ github.event.pull_request.number }}"
          echo "Please check the workflow logs and fix the issues."
